class t extends EventTarget{#t=null;updTimeout=null;lstnrs=new Map;static dc(t){return JSON.parse(JSON.stringify(t))}static nested(t,s,e,i){const r=s.split("."),n=r.pop(),h=r.reduce(((t,s)=>t[s]=t[s]??{}),t);if("set"===i)h[n]=e;else{if("rm"!==i||!h||!h.hasOwnProperty(n))return h[n];delete h[n]}}#s=new Set;#e(t){this.updTimeout&&clearTimeout(this.updTimeout),this.#s.add(t),this.updTimeout=setTimeout((()=>{this.#i()}),100)}#i(){for(const t of this.#s){let s=`update:${t}`;this.hasEvtLstnr(s)&&this.emit(s,this.get(t)),this.#s.delete(t)}this.updTimeout=null}get(t){if(!this.#t)throw new Error("State is not loaded");const s=void 0===t?this.#t:appState.nested(this.#t,t,null,"get");return s?appState.dc(s):s}set(t,s){this.qset(t,s),this.#e(t)}qset(t,s){if(!this.#t)throw new Error("State is not loaded");__o.utils.type(t,"str")&&t.includes(".")?appState.nested(this.#t,t,s,"set"):this.#t[t]=Array.isArray(this.#t[t])?[...this.#t[t],...s]:__o.utils.type(s,"obj")?{...this.#t[t],...s}:s}rm(t){if(!this.#t)throw new Error("State is not loaded");__o.utils.type(t,"str")&&t.includes(".")?appState.nested(this.#t,t,null,"rm"):delete this.#t[t],this.emitSpecEvt(t,this.#t)}rs(){if(!this.#t)throw new Error("State is not loaded");this.#t=null,this.emit("rs",this.#t)}async ld(t){if(__o.utils.type(t,"str")&&""!==t)try{const s=await fetch(t);this.#t=await s.json()}catch(t){console.error("Error fetching data:",t)}else{if(!__o.utils.type(t,"obj"))throw new Error("Invalid data type. Expected a non-empty string or an object.");this.#t=t}}on(t,s){_c(this).on(t,s),this.#r(t,1)}off(t,s){_c(this).off(t,s),this.#r(t,-1)}emit(t,s){this.dispatchEvent(new CustomEvent(t,{detail:s}))}hasEvtLstnr(t){return this.lstnrs.has(t)&&this.lstnrs.get(t)>0}#r(t,s){this.lstnrs.has(t)||this.lstnrs.set(t,0),this.lstnrs.set(t,this.lstnrs.get(t)+s)}}export{t as __oState};